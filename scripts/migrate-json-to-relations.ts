
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function migrateInvoices() {
    console.log("Migrating Invoices...");
    const invoices = await prisma.facture.findMany({
        include: { items: true } // Check existing items
    });

    let count = 0;
    for (const inv of invoices) {
        if (inv.items.length > 0) {
            console.log(`Skipping Invoice ${inv.numero} (already has items)`);
            continue;
        }

        let items = [];
        try {
            items = JSON.parse(inv.itemsJSON || "[]");
        } catch (e) {
            console.error(`Error parsing JSON for Invoice ${inv.numero}`, e);
            continue;
        }

        if (items.length === 0) continue;

        console.log(`Migrating Invoice ${inv.numero} (${items.length} items)...`);

        // Create items
        for (const item of items) {
            await prisma.factureItem.create({
                data: {
                    factureId: inv.id,
                    produitId: item.id && item.id.length < 30 ? item.id : undefined, // Check if ID is likely a valid CUID/UUID or legacy
                    // Actually, item.id in JSON might be UUID generated by frontend or DB product ID.
                    // If it matches a Product in DB, good. 
                    // But we can't guarantee constraint.
                    // Safer: Do NOT link produitId unless we are sure.
                    // Or TRY to link if it fails catch?
                    // Let's rely on description/price.
                    // Ideally we link if possible.
                    // For now, let's keep produitId undefined to be safe against FK errors, unless we verify.
                    // Wait, if I don't link, reporting is weaker.
                    // Let's try to link if item.id looks like a CUID/UUID.
                    // But if that ID doesn't exist in Product table, it will crash.
                    // So better to skip product link for this migration unless we do a lookup.
                    // Let's skip produitId for safety in this migration script, can be improved later.
                    description: item.nom || item.description || "Article",
                    quantite: Number(item.quantite) || 0,
                    prixUnitaire: Number(item.prixUnitaire) || 0,
                    tva: Number(item.tva) || 0,
                    remise: Number(item.remise) || 0,
                    remiseType: item.remiseType || 'pourcentage',
                    montantHT: Number(item.montantHT) || 0
                }
            });
        }
        count++;
    }
    console.log(`Migrated ${count} Invoices.`);
}

async function migrateQuotes() {
    console.log("Migrating Quotes...");
    const quotes = await prisma.devis.findMany({
        include: { items: true }
    });

    let count = 0;
    for (const quote of quotes) {
        if (quote.items.length > 0) {
            console.log(`Skipping Quote ${quote.numero} (already has items)`);
            continue;
        }

        let items = [];
        try {
            items = JSON.parse(quote.itemsJSON || "[]");
        } catch (e) {
            console.error(`Error parsing JSON for Quote ${quote.numero}`, e);
            continue;
        }

        if (items.length === 0) continue;

        console.log(`Migrating Quote ${quote.numero} (${items.length} items)...`);

        for (const item of items) {
            await prisma.devisItem.create({
                data: {
                    devisId: quote.id,
                    // produiId: skipped for safety
                    description: item.nom || item.description || "Article",
                    quantite: Number(item.quantite) || 0,
                    prixUnitaire: Number(item.prixUnitaire) || 0,
                    tva: Number(item.tva) || 0,
                    remise: Number(item.remise) || 0,
                    remiseType: item.remiseType || 'pourcentage',
                    montantHT: Number(item.montantHT) || 0
                }
            });
        }
        count++;
    }
    console.log(`Migrated ${count} Quotes.`);
}

async function main() {
    try {
        await migrateInvoices();
        await migrateQuotes();
        console.log("Migration Complete.");
    } catch (e) {
        console.error("Migration Failed", e);
        process.exit(1);
    }
}

main();
